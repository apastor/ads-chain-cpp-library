#include <catch2/catch.hpp>

#include <openssl/evp.h>
#include <openssl/pem.h>

#include "adschain/crypto/Signer.h"
#include "adschain/crypto/Verifier.h"
#include "TempPrivKeyFile.h"

using namespace adschain;

fruit::Component<fruit::Required<PrivateKey>, PublicKey> getPublicKeyComponent() {
  return fruit::createComponent()
      .registerProvider([](PrivateKey *privateKey) { return privateKey->getPublicKey(); });
}

fruit::Component<PublicKey, Signer> getPubKeyAndSignerComponent() {
  return fruit::createComponent()
      .install(getSignerComponent)
      .install(getPublicKeyComponent);
};

fruit::Component<PublicKey, Signer> getPubKeyAndSignerComponentFromFile(const char *filePath) {
  return fruit::createComponent()
      .install(getSignerComponentFromFile, filePath)
      .install(getPublicKeyComponent);
};

TEST_CASE("Verifier class works with autogenerated keys", "[unit]") {
  fruit::Injector<PublicKey, Signer> injector(getPubKeyAndSignerComponent);
  PublicKey *publicKey(injector);
  Signer *signer(injector);
  fruit::Injector<Verifier> injectorVerifier(getVerifierComponent);
  Verifier *verifier(injectorVerifier);
  std::string message("This is;a; string to sign;");
  SECTION("verifies good signatures") {
    std::string signatureB64 = signer->signB64(message);
    REQUIRE(verifier->verifyB64(publicKey, signatureB64, message));
  }
  SECTION("returns false on bad signatures") {
    std::string signatureB64 = signer->signB64(message);
    signatureB64[2] = signatureB64[2] + 1;
    REQUIRE_FALSE(verifier->verifyB64(publicKey, signatureB64, message));
  }
}

TEST_CASE_METHOD(TempPrivKeyFile, "Verifier class works with keys from files", "[integration]") {
  fruit::Injector<PublicKey, Signer> injector(getPubKeyAndSignerComponentFromFile, fileName.c_str());
  PublicKey *publicKey(injector);
  Signer *signer(injector);
  fruit::Injector<Verifier> injectorVerifier(getVerifierComponent);
  Verifier *verifier(injectorVerifier);
  std::string message("This is;a; string to sign;");
  SECTION("verifies good signatures") {
    std::string signatureB64 = signer->signB64(message);
    REQUIRE(verifier->verifyB64(publicKey, signatureB64, message));
  }
  SECTION("returns false on bad signatures") {
    std::string signatureB64 = signer->signB64(message);
    signatureB64[2] = signatureB64[2] + 1;
    REQUIRE_FALSE(verifier->verifyB64(publicKey, signatureB64, message));
  }
}

TEST_CASE_METHOD(TempPrivKeyFile, "PublicKey prints to string with << operator", "[unit]") {
  fruit::Injector<PublicKey, Signer> injector(getPubKeyAndSignerComponentFromFile, fileName.c_str());
  PublicKey *publicKey(injector);
//  std::cout << *publicKey << std::endl;
}